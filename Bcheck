#!/usr/bin/perl -w
#
# Bcheck -- check for new mail in "bulk" maildrops
#
# Called by xlbiff(1).  Not intended for general consumption.
#
(our $ME = $0) =~ s,.*/,,;

our $State = ".$ME.results";

use strict;
use Digest::MD5;

my $context = Digest::MD5->new;

chdir "$ENV{HOME}/Mail"
  or die "$ME: cd: $!\n";

my $seen = 0;

open FOLDERS, ".folders"
  or die "$ME: open(.folders): $!\n";
while (defined (my $f = <FOLDERS>)) {
  chomp $f;

  open SEQ, "$f/.mh_sequences"
    or next;
  while (<SEQ>) {
    if (/^unseen:\s+(.*)/) {
#      printf STDERR "$f: $1\n";
      $seen++;
      $context->add($f, $1);
    }
  }
  close SEQ;
}
close FOLDERS;

print "0\n";	# xlbiff expects this

# IF no new messages exist, pop down the window
if ($seen == 0) {
  exit 2;			# 0 = change, 1 = no change, 2 = zero'ed
}

# Read results from last time
my $last_results = "";
open LAST, $State and do {
  chop ($last_results = <LAST>);
  close LAST;
};

my $new = $context->hexdigest;
#printf STDERR "old: %s\nnew: %s\n", $last_results, $new;
if ($new eq $last_results) {
  exit 1;			# 1 = no change, 0 = change, 2 = zero'ed
}


# Something changed.
my $tmp = "$State.tmp.$$";
open OUT, ">", $tmp
  or die "$ME: Error creating $tmp: $!\n";
print OUT $new,"\n";
close OUT;

chmod 0600, $tmp;
rename $tmp => $State
  or die "$ME: rename ($tmp => $State): $!\n";

exit 0;
